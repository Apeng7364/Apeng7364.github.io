<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"apeng.re","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="有空学习一下编程语言与编译原理相关知识。看的是《自制编程语言这本书》">
<meta property="og:type" content="article">
<meta property="og:title" content="编程原理学习笔记（一）">
<meta property="og:url" content="http://apeng.re/2020/02/10/programming-language-note-1/index.html">
<meta property="og:site_name" content="Apeng&#39;s blog">
<meta property="og:description" content="有空学习一下编程语言与编译原理相关知识。看的是《自制编程语言这本书》">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-10T08:30:24.000Z">
<meta property="article:modified_time" content="2023-03-24T14:14:17.112Z">
<meta property="article:author" content="Apeng">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://apeng.re/2020/02/10/programming-language-note-1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://apeng.re/2020/02/10/programming-language-note-1/","path":"/2020/02/10/programming-language-note-1/","title":"编程原理学习笔记（一）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编程原理学习笔记（一） | Apeng's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Apeng's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Apeng's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Reverse Everything</p>
      <img class="custom-logo-image" src="/uploads/custom-logo.png" alt="Apeng's blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">语法处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lexyacc%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">使用lex+yacc编写一个简单计算器程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">词法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%9D%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">定义区块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E5%8C%BA%E5%9D%97"><span class="nav-number">3.1.2.</span> <span class="nav-text">规则区块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97"><span class="nav-number">3.1.3.</span> <span class="nav-text">用户代码区块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lex%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.1.4.</span> <span class="nav-text">lex中的正则表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%9D%97-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">定义区块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">非终结符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E5%8C%BA%E5%9D%97-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">规则区块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">用户代码区块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">语法分析器的执行过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">生成可执行文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Apeng7364" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Apeng7364" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:apeng622@gmail.com" title="E-Mail → mailto:apeng622@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Apeng_7364" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Apeng_7364" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="/friends" title="&#x2F;friends">Friends</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://apeng.re/2020/02/10/programming-language-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apeng's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编程原理学习笔记（一） | Apeng's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编程原理学习笔记（一）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-10 16:30:24" itemprop="dateCreated datePublished" datetime="2020-02-10T16:30:24+08:00">2020-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-24 22:14:17" itemprop="dateModified" datetime="2023-03-24T22:14:17+08:00">2023-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>有空学习一下编程语言与编译原理相关知识。看的是《自制编程语言这本书》</p>
<span id="more"></span>
<h2 id="环境搭建">环境搭建</h2>
<p>开发语言是C，工具使yacc和lex，环境为Ubuntu子系统。</p>
<p>先安装gcc make cmake ，然后是bison(yacc)和flex(lex)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc make cmake bison flex</span><br></pre></td></tr></table></figure>
<h2 id="语法处理">语法处理</h2>
<p>分为4个阶段： 1. 词法分析
将源代码分为若干个<strong>记号</strong>（token）。 2. 语法分析
从记号构建<strong>分析树</strong>，或称之为<strong>语法树</strong>/<strong>抽象语法树</strong>。
3. 语义分析
检查是否含有语法正确但存在逻辑问题的错误。还会进行数据类型的检查。 4.
生成代码 进入代码生成阶段</p>
<p>执行词法分析的程序，称为<strong>词法分析器</strong>。lex是编写词法分析器的工具
执行语法分析的程序，称为<strong>解析器</strong>。yacc是编写语法分析器的工具</p>
<blockquote>
<p>yacc是<code>Yet Another Compiler Compiler</code>的缩写，即又一个生成编译器的编译器。实际上只是解析器部分。</p>
<p>lex则是<code>lexical analyzer</code>的缩写。</p>
</blockquote>
<p>由于词法分析是早于语法分析的，所以就能解释i+++++j这句编译报错的原因了。i+++++j被词法分析拆分成了<code>i</code>
<code>++</code> <code>++</code> <code>+</code>
<code>j</code>，从而导致语法分析时出错。</p>
<h2 id="使用lexyacc编写一个简单计算器程序">使用lex+yacc编写一个简单计算器程序</h2>
<p>最终的效果需要输入任何一个式子，得到式子的结果，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1+2</span><br><span class="line">&gt;&gt; 3.000000</span><br><span class="line">1+2*3</span><br><span class="line">&gt;&gt; 7.000000</span><br></pre></td></tr></table></figure>
<h3 id="词法分析">词法分析</h3>
<p>lex是生成一个词法分析器的工具。我们需要编写.l文件，lex输入.l文件，输出词法分析器的C语言代码。flex则是增强版的lex。</p>
<p>词法分析器将输入的字符串分割为记号，因此先要想好我们都使用哪些记号。简单的计算器程序应当至少包含这些记号：</p>
<ul>
<li>运算符。基本的四则运算运算符，即<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>。</li>
<li>实数。包含整数和小数。小数先忽略包含e的浮点数表示法。</li>
<li>换行符。输入换行符就会执行计算，因此换行符应设置为记号。</li>
<li>空白符。空格和制表符应当被略过。</li>
</ul>
<blockquote>
<p>为简单起见，先不考虑括号</p>
</blockquote>
<p>一个.l文件由定义区块，规则区块，用户代码区块组成。区块间用%%分隔。</p>
<h4 id="定义区块">定义区块</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">yywrap()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<p>定义区块内可以定义初始状态或为正则表达式命名（以方便直接调用）等。</p>
<p>使用<code>%&#123;</code>和<code>&#125;%</code>包裹的部分，词法分析器会将之原样输出：</p>
<p>这里原样输出了一些代码，作为最终代码的起始部分，包括包含头文件。其中y.tab.h是之后yacc自动生成的头文件，等之后可以回过头来再看。</p>
<p>yywrap函数直接返回了1。如果没有这个函数就必须手动链接lex库文件，在不同编译环境时比较麻烦，因此最好写上。</p>
<blockquote>
<p>When the scanner receives an end-of-file indication from YY_INPUT, it
then checks the <code>yywrap()</code> function. If <code>yywrap()</code>
returns false (zero), then it is assumed that the function has gone
ahead and set up yyin to point to another input file, and scanning
continues. If it returns true (non-zero), then the scanner terminates,
returning 0 to its caller. Note that in either case, the start condition
remains unchanged; it does not revert to INITIAL.</p>
<p>If you do not supply your own version of <code>yywrap()</code>, then
you must either use <code>%option noyywrap</code> (in which case the
scanner behaves as though <code>yywrap()</code> returned 1), or you must
link with <code>-lfl</code> to obtain the default version of the
routine, which always returns 1.</p>
</blockquote>
<h4 id="规则区块">规则区块</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;+&quot;     return ADD;</span><br><span class="line">&quot;-&quot;     return SUB;</span><br><span class="line">&quot;*&quot;     return MUL;</span><br><span class="line">&quot;/&quot;     return DIV;</span><br><span class="line">&quot;\n&quot;    return CR;</span><br><span class="line">(0|([1-9][0-9]*))(\.[0-9]*)? &#123;</span><br><span class="line">    double temp;</span><br><span class="line">    sscanf(yytext, &quot;%lf&quot;, &amp;temp);</span><br><span class="line">    yylval.double_value = temp;</span><br><span class="line">    return DOUBLE_LITERAL;</span><br><span class="line">&#125;</span><br><span class="line">[ \t] ;</span><br><span class="line">. &#123;</span><br><span class="line">    fprintf(stderr, &quot;lexical error, value: %s&quot;, yytext);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则区块使用正则表达式描述记号。</p>
<p>记号一般包含三部分含义，分别是： 1. 记号的原始字符串
一个记号包含输入的原始字符串，比如<code>123.456</code>的原始字符串<code>"123.456"</code>，内存中应当用8字节保存（包括结尾的\0）
2. 记号的种类
描述一个记号的种类，一般用大写字母表示，比如123.456的种类为实常量（DOUBLE_LITERAL）
3. 记号的值
记号代表具体的数值，比如123.456代表double类型的双精度浮点数123.456，在内存中应当用8字节保存。</p>
<p>对于运算符，只需关注记号种类。而数值类的记号还需关心记号的值。</p>
<p>规则区块的书写方式：一个正则表达式，后面接C代码（如果多于一行应用大括号包裹）。如果输入的字符串匹配正则表达式，则执行后面的C代码。这部分C代码称为动作。</p>
<p>前5行负责处理四则运算字符和回车。注意这里的双引号是正则的转义字符（这种风格的正则表达式支持这种转义的方式），也可以写成<code>\+</code>、<code>\-</code>、<code>\*</code>、<code>\/</code>
后面接了一句C语言语句，直接返回了对应的标识符。现在可能无法理解具体含义，后面继续学。</p>
<p>接下来是处理浮点数值的部分。前面的略复杂的正则表示负责匹配所有的实数，包括<code>123</code>，<code>123.456</code>。这里的正则可能并非最优，暂时无法匹配<code>1e10</code>，<code>.2</code>这种C风格的浮点数，不过暂且够用。不太清楚这里的正则具体的规则，会不会和其他的不一样<del>，找了篇资料以后慢慢研究</del>。“记号的原始字符串”会被全局变量<code>yytext</code>引用。接下来<code>sscanf</code>函数解析这个字符串，并将解析的结果存放在<code>yylaval</code>这个全局变量中。<code>yylval</code>是一个联合体（union），可以存放各种类型记号的值。此变量的定义写在yacc的定义文件calc.y中，具体见下文。</p>
<h4 id="用户代码区块">用户代码区块</h4>
<p>这一部分可以编写任意C代码，并且不用<code>%&#123;</code>和<code>%&#125;</code>包裹。本例中没有用户代码区块。</p>
<h4 id="lex中的正则表达式">lex中的正则表达式</h4>
<p>书上的匹配实数的正则表达式似乎有点问题，待之后运行起来测试。</p>
<p>这是一个匹配C风格浮点数的正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-+]?(([1-9][0-9]*)|0)(\.[0-9]*)?([eE][-+]?(([1-9][0-9]*)|0))?</span><br></pre></td></tr></table></figure>
<p>待补充</p>
<h3 id="语法分析">语法分析</h3>
<p>yacc则是生成解析器的工具。我们需要编写yacc的.y文件。向yacc程序输入.y文件，就会输出语法分析器的C语言代码。bison则是yacc的增强版。</p>
<p>yacc的.y文件同样也由区块组成，也分别为定义区块，规则区块，用户代码区块，区块间用<code>%%</code>分隔</p>
<h4 id="定义区块-1">定义区块</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define YYDEBUG 1</span><br><span class="line">%&#125;</span><br><span class="line">%union &#123;</span><br><span class="line">    int     int_value;</span><br><span class="line">    double  double_value;</span><br><span class="line">&#125;</span><br><span class="line">%token &lt;double_value&gt; DOUBLE_LITERAL</span><br><span class="line">%token ADD SUB MUL DIV CR</span><br><span class="line">%type &lt;double_value&gt; expression term primary_expression</span><br></pre></td></tr></table></figure>
<p>与lex相同开头先用<code>%&#123;</code>和<code>%&#125;</code>包裹了一部分C代码，负责包含头文件，并且用预处理定义了<code>YYDEBUG</code>的值为1，这样能开启调试模式，方便调试查看程序运行中语法分析的状态。调试部分之后学习。</p>
<p>接下来声明了记号以及<strong>非终结符</strong>的种类。记号可能会有很多类型，这些类型都声明在这个联合体中。本例其实只用到double类型。为方便说明多定义了一个int类型没有用到。</p>
<p>非终结符由记号组成，最后以一个特殊记号<strong>终结符</strong>组成。</p>
<p>接下来是声明记号。第一种记号<code>DOUBLE_LITERAL</code>是实常量，用尖括号<code>&lt;&gt;</code>包裹指定类型为double_value，即上文定义的记号的种类。对于不关心数值的记号即<code>ADD</code>
<code>SUB</code> <code>MUL</code> <code>DIV</code> <code>CR</code>
，无需指定类型。</p>
<p>最后声明这些非终结符的类型，指明为<code>double_value</code>。</p>
<blockquote>
<h5 id="非终结符">非终结符</h5>
<p>我的理解是一个句子由若干个非终结符和一个终结符组成。非终结符由若干个记号组成。这些记号组合起来可能也代表着数值。比如<code>3+5</code>这句话，<code>3</code>,<code>+</code>,<code>5</code>都是几号，<code>3</code>和<code>5</code>具有具体的数值，<code>+</code>不具有数值，代表着相加，于是<code>3+5</code>这个非终结符应当表示<code>8</code>的数值，即所谓的非终结符的数值和类型。</p>
</blockquote>
<h4 id="规则区块-1">规则区块</h4>
<p>定义区块之后是规则区块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">line_list</span><br><span class="line">    : line</span><br><span class="line">    | line_list line</span><br><span class="line">    ;</span><br><span class="line">line</span><br><span class="line">    : expression CR</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;&gt;&gt;%lf\n&quot;, $1);</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">expression</span><br><span class="line">    : term</span><br><span class="line">    | expression ADD term</span><br><span class="line">    &#123;</span><br><span class="line">        $$ = $1 + $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | expression SUB term</span><br><span class="line">    &#123;</span><br><span class="line">        $$ = $1 - $3;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">term</span><br><span class="line">    : primary_expression</span><br><span class="line">    | term MUL primary_expression</span><br><span class="line">    &#123;</span><br><span class="line">        $$ = $1 * $3;</span><br><span class="line">    &#125;</span><br><span class="line">    | term DIV primary_expression</span><br><span class="line">    &#123;</span><br><span class="line">        $$ = $1 / $3;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">primary_expression</span><br><span class="line">    : DOUBLE_LITERAL</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>规则区块的每一条规则由语法规则和C语言编写的动作两部分组成。在yacc中使用BNF（巴科斯范式，Backus
Normal Form）规范来编写规则。</p>
<p>初步看起来有点复杂，实际上每条规则书写方式都是这样的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">	: B /* A 产生 B / B 规约成A ，可不执行动作 */</span><br><span class="line">	| C D /* 或，A 产生C D / C D 规约成 A*/</span><br><span class="line">	&#123;</span><br><span class="line">		/* A产生C D / C D规约成A 时执行的动作 */</span><br><span class="line">	&#125;</span><br><span class="line">	; /* 分号表示一条规则结束 */</span><br></pre></td></tr></table></figure>
<p>文中A、B、C、D都是非终结符，即表示A的定义是B或是C与D的结合。</p>
<p>巴科斯范式是一种上下文无关文法，足够简单且容易构造分析算法来分析句子。如果将上述例子写成产生式规则是这样的：
<span class="math display">\[
A\to B | CD
\]</span> 我们的简单计算机程序的文法应该是这样的： <span class="math display">\[
\begin{align}
&amp;G =(N,\Sigma,P,S)\\
&amp;N =\{line\_list, line, expression, term, primary\_expression\}\\
&amp;\Sigma =\{DOUBLE\_LITERAL, ADD, SUB, MUL, DIV, CR\}\\
&amp;S =line\_list\\
&amp;P由以下产生式规则组成：\\
&amp;1.line\_list\to line|line\_list\ line\\
&amp;2.line\to expression\ CR\\
&amp;3.expression\to term|expression\ ADD\ term|expression\ SUB\ term\\
&amp;4.term\to primary\_expression|term\ MUL\ primary\_expression|term\
DIV\ primary\_expression\\
&amp;5.primary\_expression\to DOUBLE\_LITERAL\\
\end{align}
\]</span>
可能这样看比较接近我们形式语言与自动机中学的理论了。BNF的书写规则有些许不同，大体上相似。</p>
<p>下面解释一下这些产生式规则的含义。</p>
<p><code>line_list</code>与<code>line</code>是用来表示一句话可能出现一句以上。在本例中，我们需要循环输入表达式以得到结果，所以需要设计成支持出现一次以上的模式。line_list产生line_list
line这种形式以实现无穷多句话。</p>
<p>每一行line产生expression和CR，即一个表达式和换行符。输入回车后，表示这句话结束了，应当输出结果，所以动作是将表达式的值输出。同时没有对$$赋值，则数据没有保留。</p>
<p>表达式可以是单独的一个项，也可以是表达式加项或表达式减项</p>
<blockquote>
<p>一开始我对这里有些异或，表达式也可以是项加减项啊，为什么不包括这一条呢？后续探讨这个问题</p>
</blockquote>
<p>项可以是单独的一元表达式，或是项乘以一元表达式或除以。</p>
<p>一元表达式则是实常量。</p>
<p>此外，在语法规则中包含了运算符的优先级顺序以及结合规律，即先乘除后加减。具体是为何能实现的需要更多理论知识。</p>
<p>每条规则被触发时，可以执行一定的动作，即每条规则后的C语言语句。比如乘法对应执行的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">term</span><br><span class="line">	: term MUL primary_expression</span><br><span class="line">	&#123;</span><br><span class="line">		$$ = $1 * $3;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>产生式中的非终结符的值被以此保存在<code>$1</code>,<code>$2</code>,<code>$3</code>等变量中。<code>$$</code>表示当前栈的值，可以理解为规约后的term的值。</p>
<p>同时，如果书写动作时，yacc会补全一个<code>&#123;$$ = $1;&#125;</code>的动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primary_expression</span><br><span class="line">	: DOUBLE_LITERAL</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">primary_expression</span><br><span class="line">	: DOUBLE_LITERAL</span><br><span class="line">	&#123;</span><br><span class="line">		$$ = $1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因此本例中的所有非终结符都是有具体数值的，类型为double_vale（在定义区块中定义）</p>
<h4 id="用户代码区块-1">用户代码区块</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span>* yytext;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;parser error near %s\n&quot;</span>, yytext);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">yyparse</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">extern</span> FILE* yyin;</span><br><span class="line"></span><br><span class="line">    yyin = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">if</span> (yyparse()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR! ERROR! ERROR!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此处编写我们的程序的main函数。全局变量yyin设定输入，然后调用yyparse()函数解析。</p>
<p>还要定义一个回调函数yyerror，当解析失败时会调用并给出回显。</p>
<h4 id="语法分析器的执行过程">语法分析器的执行过程</h4>
<p>语法分析执行时回实现一个栈，所有的记号会按顺序在中依次移进，并根据产生式规则进行规约并执行动作。</p>
<p>以<code>1+2*3</code>为例，图解详细的分析过程。</p>
<p>首先字符串被词法分析器分割成了一个个记号。</p>
<p>
<button>
DOUBLE_LITERAL
</button>
<button>
ADD
</button>
<button>
DOUBLE_LITERAL
</button>
<button>
MUL
</button>
<button>
DOUBLE_LITERAL
</button>
</p>
<p>这里词法分析器分析完后就已经变成记好了，对应着<code>1</code>,<code>+</code>,<code>2</code>,<code>*</code>,<code>3</code>这些字符。同样这些<code>DOUBLE_LITERAL</code>也有具体的数值了。</p>
<p>然后按顺序记号依次入栈，成为<strong>移进</strong>（shift）。</p>
<p>首先是记号1移进，记号<code>ADD</code>为下一个等待移进：</p>
<p>
<div align="center">
<pre><code>    Next: 
    &lt;button&gt;ADD&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;DOUBLE_LITERAL&lt;/button&gt; ......</code></pre>
</div></p>
<p>记号<code>1</code>触发规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primary_expression</span><br><span class="line">	: DOUBLE_LITERAL</span><br></pre></td></tr></table></figure>
<p>归约成<code>primary_expression</code>:</p>
<p>
<div align="center">
<pre><code>Next: &lt;button&gt;ADD&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;primary_expression&lt;/button&gt; ......</code></pre>
</div></p>
<p><code>primary_expression</code>不会和<code>ADD</code>触发规则。而自身触发规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">term</span><br><span class="line">	: primary_expression</span><br></pre></td></tr></table></figure>
<p>归约成<code>term</code>：</p>
<p>
<div align="center">
<pre><code>Next: &lt;button&gt;SUB&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;term&lt;/button&gt; ......</code></pre>
</div></p>
<p><code>term</code>还是不会和<code>ADD</code>触发规则，自身继续触发规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expression</span><br><span class="line">	: term</span><br></pre></td></tr></table></figure>
<p>归约成<code>expression</code>：</p>
<p>
<div align="center">
<pre><code>Next: &lt;button&gt;ADD&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; ......</code></pre>
</div></p>
<p>此时单独的expression似乎不能继续触发规则而归约了。</p>
<p>接下来记号<code>+</code>移进：</p>
<p>
<div align="center">
<pre><code>    Next: &lt;button&gt;DOUBLE_LITERAL&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; ......</code></pre>
</div></p>
<p>此时不能触发任何规则，于是继续移进下一个记号：</p>
<p>
<div align="center">
<pre><code>    Next: &lt;button&gt;MUL&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;DOUBLE_LITERAL&lt;/button&gt; ......</code></pre>
</div></p>
<p>单独的DOUBLE_LITERAL还是归约成<code>primary_expression</code></p>
<p>
<div align="center">
<pre><code>    Next: &lt;button&gt;MUL&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;primary_expression&lt;/button&gt; ......</code></pre>
</div></p>
<p>还是继续归约为<code>term</code>：</p>
<p>
<div align="center">
<pre><code>    Next: &lt;button&gt;MUL&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;term&lt;/button&gt; ......</code></pre>
</div></p>
<p>接下来就有些不一样的地方了。<code>expression</code> <code>ADD</code>
<code>term</code>可以触发规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expression</span><br><span class="line">	: expression ADD term</span><br></pre></td></tr></table></figure>
<p>然而下一个记号是<code>MUL</code>，由于有规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">term</span><br><span class="line">	: term MUL primary_expression</span><br></pre></td></tr></table></figure>
<p>所以这里不能归约，要接下来的归约情况，因此不做归约，继续移进下一个记号：</p>
<p>
<div align="center">
<pre><code>    Next: &lt;button&gt;DOUBLE_LITERAL&lt;/button&gt;
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;term&lt;/button&gt; 
&lt;button&gt;MUL&lt;/button&gt; ......</code></pre>
</div></p>
<p>此时还不能归约，继续移进</p>
<p>
<div align="center">
<pre><code>    Next: 
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;term&lt;/button&gt; 
&lt;button&gt;MUL&lt;/button&gt; 
&lt;button&gt;DOUBLE_LITERAL&lt;/button&gt; ......</code></pre>
</div></p>
<p>此时，前三个匹配一个规则，后三个记号匹配一个规则。这里会将后三个记号归约成<code>term</code>（为什么不会产生冲突暂时不清楚）：</p>
<p>
<div align="center">
<pre><code>    Next: 
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; 
&lt;button&gt;ADD&lt;/button&gt; 
&lt;button&gt;term&lt;/button&gt;  ......</code></pre>
</div></p>
<p>同时归约的时候执行动作，计算2*3的值，并存入栈中规约后的非终结符<code>term</code></p>
<p>继续触发规则，归约成<code>expression</code>:</p>
<p>
<div align="center">
<pre><code>    Next: 
&lt;/div&gt;
&lt;button&gt;expression&lt;/button&gt; ......</code></pre>
</div></p>
<p>同样计算<code>$1+$3</code>，得到结果7。</p>
<h3 id="生成可执行文件">生成可执行文件</h3>
<p>接下来就可以使用lex和yacc生成源代码，然后编译并链接生成可执行文件：</p>
<p>首先用lex或flex生成词法分析器的C代码<code>lex.yy.c</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flex calc.l</span><br><span class="line"><span class="comment"># 或者用 lex calc.l</span></span><br></pre></td></tr></table></figure>
<p>然后使用yacc或bison生成语法分析器的C代码<code>y.tab.c</code>和<code>y.tab.h</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bison -dv --yacc calc.y</span><br><span class="line"><span class="comment"># 或者用 yacc -dv calc.y</span></span><br></pre></td></tr></table></figure>
<p>选项<code>--yacc</code>是为了使生成的文件名为<code>y.tab.c</code>和<code>y.tab.h</code>,<code>lex.yy.c</code>即<code>calc.l</code>中需要正确包含这个头文件。如果不加<code>--yacc</code>生成的文件名为<code>calc.tab.c</code>和<code>calc.tab.h</code>。</p>
<p><code>-d</code>会生成头文件，共<code>lex.yy.c包含</code>。<code>-v</code>会生成一个<code>.output</code>文件，它会包含所有的语法规则，解析器，所有可能的分支状态以及编译器启动信息。</p>
<p>之后可以用gcc编译成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o calc y.tab.c lex.yy.c</span><br></pre></td></tr></table></figure>
<p>程序执行最终效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./calc</span><br><span class="line">3*3+1</span><br><span class="line">&gt;&gt;10.000000</span><br><span class="line">1.2*5</span><br><span class="line">&gt;&gt;6.000000</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>简单了解了编译器的组成，了解了使用lex+yacc书写一个编译器前端的过程。初步了解lex与yacc的使用方法，编写了一个简单的计算器程序。</p>
<p>编写过程中对词法分析和语法分析有了初步的了解。</p>
<h2 id="参考资料">参考资料</h2>
<p>The Flex Manual Page:
http://dinosaur.compilertools.net/flex/manpage.html LEX regular
expressions:
http://www.csd.uwo.ca/~moreno/CS447/Lectures/Lexical.html/node11.html
Formal grammar: https://en.wikipedia.org/wiki/Formal_grammar Backus–Naur
form: https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Apeng
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://apeng.re/2020/02/10/programming-language-note-1/" title="编程原理学习笔记（一）">http://apeng.re/2020/02/10/programming-language-note-1/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag"># 编译原理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/09/wsl-note/" rel="prev" title="wsl 使用笔记">
                  <i class="fa fa-angle-left"></i> wsl 使用笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/02/11/programming-language-note-2/" rel="next" title="编译原理学习笔记（二）">
                  编译原理学习笔记（二） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Apeng</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Apeng7364" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
